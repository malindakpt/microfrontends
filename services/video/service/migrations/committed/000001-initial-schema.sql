--! Previous: -
--! Hash: sha1:d2a36f09cfeaf430a44a7b786f7f349606e0d333
--! Message: initial-schema

-- NAVIGATION:
-- section headings: https://textfancy.com/multiline-text-art/ style "Meh"
-- search for this to jump to the corresponding sections:
-- * #general
-- * #setting
-- * #video

-------------- #general ---------------
--                                   _
--  __ _  ___  _ _   ___  _ _  __ _ | |
-- / _` |/ -_)| ' \ / -_)| '_|/ _` || |
-- \__. |\___||_||_|\___||_|  \__/_||_|
-- |___/
---------------------------------------

-- it is important that the DB is based on UTC for date and time data types
ALTER DATABASE :DB_NAME SET timezone TO 'UTC';

-- NOTE: enum values must all be UPPER CASE!

-- type: transcoding_status
DROP TYPE IF EXISTS app_public.transcoding_status CASCADE;
CREATE TYPE app_public.transcoding_status AS enum (
  'WAITING',
  'IN_PROGRESS',
  'READY',
  'ERROR'
);
SELECT app_hidden.expose_enum_endpoint('transcoding_status', 'app_public');

-- type: qa_status
DROP TYPE IF EXISTS app_public.qa_status CASCADE;
CREATE TYPE app_public.qa_status AS enum (
  'NOT_PREVIEWED',
  'NOT_APPROVED',
  'APPROVED'
);
SELECT app_hidden.expose_enum_endpoint('qa_status', 'app_public');

-- type: output_format
DROP TYPE IF EXISTS app_public.output_format CASCADE;
CREATE TYPE app_public.output_format AS enum (
  'HLS',
  'DASH',
  'HLS_DASH',
  'CMAF'
);
SELECT app_hidden.expose_enum_endpoint('output_format', 'app_public');

-- type: archiving
-- reference: https://wiki.axinom.com/display/VES/TAR+archiving
DROP TYPE IF EXISTS app_public.archiving CASCADE;
CREATE TYPE app_public.archiving AS enum (
  'NONE',
  'TAR',
  'SINGLE_TAR'
);
SELECT app_hidden.expose_enum_endpoint('archiving', 'app_public');

-- type: drm_protection
DROP TYPE IF EXISTS app_public.drm_protection CASCADE;
CREATE TYPE app_public.drm_protection AS enum (
  'NONE',
  'MANAGED'
);
SELECT app_hidden.expose_enum_endpoint('drm_protection', 'app_public');

-------------- #setting --------------
--  ___       _    _    _
-- / __| ___ | |_ | |_ (_) _ _   __ _
-- \__ \/ -_)|  _||  _|| || ' \ / _` |
-- |___/\___| \__| \__||_||_||_|\__. |
--                              |___/
--------------------------------------

-- table: transcoding_acquisition_profiles
DROP TABLE IF EXISTS app_public.transcoding_acquisition_profiles CASCADE;
CREATE TABLE app_public.transcoding_acquisition_profiles (
  id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  title text NOT NULL,
  is_valid boolean NOT NULL DEFAULT FALSE,

  provider text,
  uri_path text,
  root_folder_path text,
  read_credentials_name text,
  read_credentials_secret text,
  list_credentials_name text,
  list_credentials_secret text,
  created_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc'),
  updated_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc'),
  created_user text NOT NULL,
  updated_user text NOT NULL,

  CONSTRAINT title_max_length CHECK(app_hidden.constraint_max_length(title, 100, 'The title can only be %2$s characters long.')),
  CONSTRAINT title_not_empty CHECK(app_hidden.constraint_not_empty(title, 'The title cannot be empty.'))
);

-- INSERT and DELETE are skipped on purpouse because we support only 1 default profile, which is created on startup and we only want to be able to select and update it.
-- This is also the reason no indexes are defined
GRANT SELECT ON app_public.transcoding_acquisition_profiles TO :DATABASE_VISITOR;
GRANT UPDATE (
  title,
  uri_path,
  root_folder_path,
  read_credentials_name,
  read_credentials_secret,
  list_credentials_name,
  list_credentials_secret
) ON app_public.transcoding_acquisition_profiles TO :DATABASE_VISITOR;

SELECT app_hidden.define_timestamps_trigger('transcoding_acquisition_profiles', 'app_public');
SELECT app_hidden.define_users_trigger('transcoding_acquisition_profiles', 'app_public');
SELECT app_hidden.define_authentication('ADMIN', 'ADMIN', 'transcoding_acquisition_profiles', 'app_public');

CREATE OR REPLACE FUNCTION app_hidden.tg_transcoding_acquisition_profiles__check_validity() RETURNS trigger AS $$
BEGIN
  NEW.is_valid = app_hidden.validation_not_empty(NEW.provider) AND 
                 app_hidden.validation_not_empty(NEW.uri_path) AND 
                 app_hidden.validation_is_url(NEW.uri_path) AND 
                 app_hidden.validation_not_empty(NEW.read_credentials_name) AND 
                 app_hidden.validation_not_empty(NEW.read_credentials_secret) AND 
                 app_hidden.validation_is_base64(NEW.read_credentials_secret) AND  
                 app_hidden.validation_not_empty(NEW.list_credentials_secret) AND 
                 app_hidden.validation_starts_with(NEW.list_credentials_secret, '?');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql volatile SET search_path TO pg_catalog, public, pg_temp;

DROP trigger IF EXISTS _300_check_validity on app_public.transcoding_acquisition_profiles;
CREATE trigger _300_check_validity
BEFORE INSERT OR UPDATE ON app_public.transcoding_acquisition_profiles
for each ROW
EXECUTE PROCEDURE app_hidden.tg_transcoding_acquisition_profiles__check_validity();

-- table: transcoding_publishing_profiles
DROP TABLE IF EXISTS app_public.transcoding_publishing_profiles CASCADE;
CREATE TABLE app_public.transcoding_publishing_profiles (
  id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  title text NOT NULL,
  is_valid boolean NOT NULL DEFAULT FALSE,

  provider text,
  uri_path text,
  credentials_name text,
  credentials_secret text,
  created_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc'),
  updated_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc'),
  created_user text NOT NULL,
  updated_user text NOT NULL,

  CONSTRAINT title_max_length CHECK(app_hidden.constraint_max_length(title, 100, 'The title can only be %2$s characters long.')),
  CONSTRAINT title_not_empty CHECK(app_hidden.constraint_not_empty(title, 'The title cannot be empty.'))
);

-- INSERT and DELETE are skipped on purpouse because we support only 1 default profile, which is created on startup and we only want to be able to select and update it.
-- This is also the reason no indexes are defined
GRANT SELECT ON app_public.transcoding_publishing_profiles TO :DATABASE_VISITOR;
GRANT UPDATE (
  title,
  uri_path,
  credentials_name,
  credentials_secret
) ON app_public.transcoding_publishing_profiles TO :DATABASE_VISITOR;

SELECT app_hidden.define_timestamps_trigger('transcoding_publishing_profiles', 'app_public');
SELECT app_hidden.define_users_trigger('transcoding_publishing_profiles', 'app_public');
SELECT app_hidden.define_authentication('ADMIN', 'ADMIN', 'transcoding_publishing_profiles', 'app_public');

CREATE OR REPLACE FUNCTION app_hidden.tg_transcoding_publishing_profiles__check_validity() RETURNS trigger AS $$
BEGIN
  NEW.is_valid = app_hidden.validation_not_empty(NEW.provider) AND 
                 app_hidden.validation_not_empty(NEW.uri_path) AND 
                 app_hidden.validation_is_url(NEW.uri_path) AND 
                 app_hidden.validation_not_empty(NEW.credentials_name) AND 
                 app_hidden.validation_not_empty(NEW.credentials_secret) AND 
                 app_hidden.validation_is_base64(NEW.credentials_secret);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql volatile SET search_path TO pg_catalog, public, pg_temp;

DROP trigger IF EXISTS _300_check_validity on app_public.transcoding_publishing_profiles;
CREATE trigger _300_check_validity
BEFORE INSERT OR UPDATE ON app_public.transcoding_publishing_profiles
for each ROW
EXECUTE PROCEDURE app_hidden.tg_transcoding_publishing_profiles__check_validity();

-- table: transcoding_processing_profiles
DROP TABLE IF EXISTS app_public.transcoding_processing_profiles CASCADE;
CREATE TABLE app_public.transcoding_processing_profiles (
  id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  title text NOT NULL,
  is_valid boolean NOT NULL DEFAULT FALSE,

  video_stream_expression text,
  audio_file_language_expression text,
  subtitle_file_language_expression text,
  caption_file_language_expression text,

  output_format app_public.output_format DEFAULT 'DASH',
  drm_protection app_public.drm_protection DEFAULT 'NONE',
  archiving app_public.archiving DEFAULT 'NONE',
  use_native_language_names boolean NOT NULL DEFAULT TRUE,
  delete_files_from_source_when_done boolean NOT NULL DEFAULT FALSE,
  
  drm_api_url text,
  drm_tenant_id text,
  drm_management_key text,
  drm_key_seed text,
  drm_thumbprints text,

  created_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc'),
  updated_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc'),
  created_user text NOT NULL,
  updated_user text NOT NULL,

  CONSTRAINT title_max_length CHECK(app_hidden.constraint_max_length(title, 100, 'The title can only be %2$s characters long.')),
  CONSTRAINT title_not_empty CHECK(app_hidden.constraint_not_empty(title, 'The title cannot be empty.'))
);
GRANT SELECT, DELETE ON app_public.transcoding_processing_profiles TO :DATABASE_VISITOR;
GRANT INSERT (
  title,
  video_stream_expression,
  audio_file_language_expression,
  subtitle_file_language_expression,
  caption_file_language_expression,
  output_format,
  drm_protection,
  archiving,
  use_native_language_names,
  delete_files_from_source_when_done,
  drm_api_url,
  drm_tenant_id,
  drm_management_key,
  drm_key_seed,
  drm_thumbprints
) ON app_public.transcoding_processing_profiles TO :DATABASE_VISITOR;

GRANT UPDATE (
  title,
  video_stream_expression,
  audio_file_language_expression,
  subtitle_file_language_expression,
  caption_file_language_expression,
  output_format,
  drm_protection,
  archiving,
  use_native_language_names,
  delete_files_from_source_when_done,
  drm_api_url,
  drm_tenant_id,
  drm_management_key,
  drm_key_seed,
  drm_thumbprints
) ON app_public.transcoding_processing_profiles TO :DATABASE_VISITOR;

SELECT app_hidden.define_indexes_with_id('title', 'transcoding_processing_profiles', 'app_public');
SELECT app_hidden.define_indexes_with_id('output_format', 'transcoding_processing_profiles', 'app_public');
SELECT app_hidden.define_indexes_with_id('drm_protection', 'transcoding_processing_profiles', 'app_public');
SELECT app_hidden.define_indexes_with_id('archiving', 'transcoding_processing_profiles', 'app_public');

SELECT app_hidden.define_timestamps_trigger('transcoding_processing_profiles', 'app_public');
SELECT app_hidden.define_users_trigger('transcoding_processing_profiles', 'app_public');
SELECT app_hidden.define_authentication('ADMIN', 'ADMIN', 'transcoding_processing_profiles', 'app_public');

CREATE OR REPLACE FUNCTION app_hidden.tg_transcoding_processing_profiles__check_validity() RETURNS trigger AS $$
DECLARE
  default_validity boolean;
BEGIN
  default_validity = app_hidden.validation_not_empty(NEW.video_stream_expression) AND 
                     app_hidden.validation_not_empty(NEW.audio_file_language_expression) AND 
                     app_hidden.validation_not_empty(NEW.subtitle_file_language_expression) AND 
                     app_hidden.validation_not_empty(NEW.caption_file_language_expression);

  IF NEW.drm_protection = 'MANAGED' THEN
    NEW.is_valid = default_validity AND 
                   app_hidden.validation_not_empty(NEW.drm_api_url) AND 
                   app_hidden.validation_is_url(NEW.drm_api_url) AND 
                   app_hidden.validation_not_empty(NEW.drm_tenant_id) AND 
                   app_hidden.validation_not_empty(NEW.drm_management_key) AND 
                   app_hidden.validation_is_base64(NEW.drm_management_key) AND 
                   app_hidden.validation_not_empty(NEW.drm_key_seed) AND 
                   app_hidden.validation_is_base64(NEW.drm_key_seed) AND
                   app_hidden.validation_not_empty(NEW.drm_thumbprints) AND 
                   app_hidden.validation_is_base64(NEW.drm_thumbprints);
  ELSE
    NEW.is_valid = default_validity;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql volatile SET search_path TO pg_catalog, public, pg_temp;

DROP trigger IF EXISTS _300_check_validity on app_public.transcoding_processing_profiles;
CREATE trigger _300_check_validity
BEFORE INSERT OR UPDATE ON app_public.transcoding_processing_profiles
for each ROW
EXECUTE PROCEDURE app_hidden.tg_transcoding_processing_profiles__check_validity();

-- table: transcoding_video_representations
DROP TABLE IF EXISTS app_public.transcoding_video_representations CASCADE; 
CREATE TABLE app_public.transcoding_video_representations (
  id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  transcoding_processing_profile_id integer NOT NULL REFERENCES app_public.transcoding_processing_profiles(id) ON DELETE CASCADE,

  width integer null,
  height integer null,
  bitrate_in_kbps integer NOT NULL,

  -- check that width and/or height are defined
  CONSTRAINT has_width_or_height CHECK(num_nonnulls(width, height) > 0)
);
GRANT SELECT, DELETE ON app_public.transcoding_video_representations TO :DATABASE_VISITOR;
GRANT INSERT (
  transcoding_processing_profile_id,
  width,
  height,
  bitrate_in_kbps
) ON app_public.transcoding_video_representations TO :DATABASE_VISITOR;

GRANT UPDATE (
  width,
  height,
  bitrate_in_kbps
) ON app_public.transcoding_video_representations TO :DATABASE_VISITOR;

SELECT app_hidden.define_index('transcoding_processing_profile_id', 'transcoding_video_representations', 'app_public');
SELECT app_hidden.define_authentication('ADMIN', 'ADMIN', 'transcoding_video_representations', 'app_public');

---------- #video -----------
-- __   __ _     _           
-- \ \ / /(_) __| | ___  ___ 
--  \   / | |/ _` |/ -_)/ _ \
--   \_/  |_|\__/_|\___|\___/
-----------------------------

-- table: videos
DROP TABLE IF EXISTS app_public.videos CASCADE;
CREATE TABLE app_public.videos (
  id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  title text NOT NULL,
  external_id text,
  job_id text,
  drm_key_id text,
  is_protected boolean NOT NULL DEFAULT FALSE,

  source_file_name text,
  source_file_extension text,
  source_location text NOT NULL,
  source_size_in_bytes bigint,

  audio_languages text[],
  subtitle_languages text[],
  caption_languages text[],
  video_bitrates integer[], 

  transcoding_status app_public.transcoding_status DEFAULT 'WAITING',
  output_format app_public.output_format DEFAULT 'DASH',

  qa_status app_public.qa_status DEFAULT 'NOT_PREVIEWED',
  qa_comment text,

  acquisition_progress int,
  encoding_progress int,
  
  hls_size_in_bytes bigint,
  dash_size_in_bytes bigint,
  cmaf_size_in_bytes bigint,
  hls_manifest_path text,
  dash_manifest_path text,

  duration_in_seconds int,
  is_archived boolean NOT NULL DEFAULT FALSE,
  finished_date timestamptz,
  
  created_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc'),
  updated_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc'),
  created_user text NOT NULL,
  updated_user text NOT NULL,

  CONSTRAINT title_max_length CHECK(app_hidden.constraint_max_length(title, 100, 'The title can only be %2$s characters long.')),
  CONSTRAINT title_not_empty CHECK(app_hidden.constraint_not_empty(title, 'The title cannot be empty.'))
);

SELECT app_hidden.define_unique_constraint('external_id', 'videos', 'app_public');
SELECT app_hidden.define_unique_constraint('source_location', 'videos', 'app_public');

GRANT SELECT, DELETE ON app_public.videos TO :DATABASE_VISITOR;
GRANT UPDATE (
  title,
  qa_status,
  qa_comment,
  is_archived
) ON app_public.videos TO :DATABASE_VISITOR;
SELECT app_hidden.define_subscription_triggers('id', 'videos', 'app_public', 'videos', 'Video');
SELECT app_hidden.define_indexes_with_id('title', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('output_format', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('is_protected', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('audio_languages', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('subtitle_languages', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('caption_languages', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('duration_in_seconds', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('transcoding_status', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('source_file_name', 'videos', 'app_public');
SELECT app_hidden.define_indexes_with_id('finished_date', 'videos', 'app_public');
SELECT app_hidden.define_like_index('title', 'videos', 'app_public');
SELECT app_hidden.define_like_index('source_file_name', 'videos', 'app_public');
SELECT app_hidden.define_index('qa_status', 'videos', 'app_public');
SELECT app_hidden.define_index('is_archived', 'videos', 'app_public');

SELECT app_hidden.define_timestamps_trigger('videos', 'app_public');
SELECT app_hidden.define_users_trigger('videos', 'app_public');
SELECT app_hidden.define_authentication('VIDEO_READER,VIDEO_EDITOR,ADMIN', 'VIDEO_EDITOR,ADMIN', 'videos', 'app_public');

-- table: videos_tags
DROP TABLE IF EXISTS app_public.videos_tags CASCADE;
CREATE TABLE app_public.videos_tags (
  video_id integer NOT NULL REFERENCES app_public.videos(id) ON DELETE CASCADE,
  name text NOT NULL,

  PRIMARY KEY(video_id, name),
  CONSTRAINT name_not_empty CHECK(app_hidden.constraint_not_empty(name, 'The name cannot be empty.'))
);
GRANT SELECT, INSERT, UPDATE, DELETE ON app_public.videos_tags TO :DATABASE_VISITOR;
SELECT app_hidden.define_subscription_triggers('video_id', 'videos_tags', 'app_public', 'videos', 'VideoTag');
SELECT app_hidden.define_index('video_id', 'videos_tags', 'app_public');
SELECT app_hidden.define_index('name', 'videos_tags', 'app_public');
SELECT app_hidden.define_authentication('VIDEO_READER,VIDEO_EDITOR,ADMIN', 'VIDEO_EDITOR,ADMIN', 'videos_tags', 'app_public');

-- table: transcoding_histories
DROP TABLE IF EXISTS app_public.transcoding_histories CASCADE;
CREATE TABLE app_public.transcoding_histories (
  id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  video_id integer NOT NULL REFERENCES app_public.videos(id) ON DELETE CASCADE,
  message_type text NOT NULL,
  message_body jsonb NOT NULL,
  enqueued_date timestamptz NOT NULL,
  created_date timestamptz NOT NULL DEFAULT (now() at time zone 'utc')
);
SELECT app_hidden.define_index('video_id', 'transcoding_histories', 'app_public');
SELECT app_hidden.define_indexes_with_id('enqueued_date', 'transcoding_histories', 'app_public');
SELECT app_hidden.define_indexes_with_id('created_date', 'transcoding_histories', 'app_public');
GRANT SELECT ON app_public.transcoding_histories TO :DATABASE_VISITOR;
SELECT app_hidden.define_readonly_authentication('VIDEO_READER,VIDEO_EDITOR,ADMIN', 'transcoding_histories', 'app_public');
